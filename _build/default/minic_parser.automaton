State 0:
program' -> . program [ # ]
-- On error shift to state 1
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 70
-- On typ shift to state 71
-- On simple_var_decl shift to state 141
-- On program shift to state 188
-- On global_scope_def_list shift to state 189
-- On global_scope_def shift to state 191
-- On function_decl shift to state 193
-- On EOF reduce production global_scope_def_list -> 

State 1:
program -> error . [ # ]
-- On # reduce production program -> error 

State 2:
typ -> VOID . [ IDENT ]
-- On IDENT reduce production typ -> VOID 

State 3:
variable_set -> SUB . SUB IDENT [ SEPARATOR SEMI RPAR ]
-- On SUB shift to state 4

State 4:
variable_set -> SUB SUB . IDENT [ SEPARATOR SEMI RPAR ]
-- On IDENT shift to state 5

State 5:
variable_set -> SUB SUB IDENT . [ SEPARATOR SEMI RPAR ]
-- On SEPARATOR reduce production variable_set -> SUB SUB IDENT 
-- On SEMI reduce production variable_set -> SUB SUB IDENT 
-- On RPAR reduce production variable_set -> SUB SUB IDENT 

State 6:
typ -> INT . [ IDENT ]
-- On IDENT reduce production typ -> INT 

State 7:
variable_set -> IDENT . SET expression [ SEPARATOR SEMI RPAR ]
variable_set -> IDENT . ADD ADD [ SEPARATOR SEMI RPAR ]
variable_set -> IDENT . SUB SUB [ SEPARATOR SEMI RPAR ]
-- On SUB shift to state 8
-- On SET shift to state 10
-- On ADD shift to state 62

State 8:
variable_set -> IDENT SUB . SUB [ SEPARATOR SEMI RPAR ]
-- On SUB shift to state 9

State 9:
variable_set -> IDENT SUB SUB . [ SEPARATOR SEMI RPAR ]
-- On SEPARATOR reduce production variable_set -> IDENT SUB SUB 
-- On SEMI reduce production variable_set -> IDENT SUB SUB 
-- On RPAR reduce production variable_set -> IDENT SUB SUB 

State 10:
variable_set -> IDENT SET . expression [ SEPARATOR SEMI RPAR ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 61
-- On bool_op shift to state 56

State 11:
expression -> LPAR . expression RPAR [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 59
-- On bool_op shift to state 56

State 12:
expression -> IDENT . LPAR funcall_args RPAR [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
expression -> IDENT . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 13
-- On XOR reduce production expression -> IDENT 
-- On SUB reduce production expression -> IDENT 
-- On SEPARATOR reduce production expression -> IDENT 
-- On SEMI reduce production expression -> IDENT 
-- On RPAR reduce production expression -> IDENT 
-- On OR reduce production expression -> IDENT 
-- On NEQ reduce production expression -> IDENT 
-- On MUL reduce production expression -> IDENT 
-- On MOD reduce production expression -> IDENT 
-- On LT reduce production expression -> IDENT 
-- On LET reduce production expression -> IDENT 
-- On GT reduce production expression -> IDENT 
-- On GET reduce production expression -> IDENT 
-- On EQ reduce production expression -> IDENT 
-- On END reduce production expression -> IDENT 
-- On DOTS2 reduce production expression -> IDENT 
-- On DIV reduce production expression -> IDENT 
-- On BXOR reduce production expression -> IDENT 
-- On BOR reduce production expression -> IDENT 
-- On BNEQ reduce production expression -> IDENT 
-- On BAND reduce production expression -> IDENT 
-- On AND reduce production expression -> IDENT 
-- On ADD reduce production expression -> IDENT 

State 13:
expression -> IDENT LPAR . funcall_args RPAR [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On funcall_args shift to state 17
-- On expression shift to state 19
-- On bool_op shift to state 56
-- On RPAR reduce production funcall_args -> 

State 14:
expression -> CST . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> CST 
-- On SUB reduce production expression -> CST 
-- On SEPARATOR reduce production expression -> CST 
-- On SEMI reduce production expression -> CST 
-- On RPAR reduce production expression -> CST 
-- On OR reduce production expression -> CST 
-- On NEQ reduce production expression -> CST 
-- On MUL reduce production expression -> CST 
-- On MOD reduce production expression -> CST 
-- On LT reduce production expression -> CST 
-- On LET reduce production expression -> CST 
-- On GT reduce production expression -> CST 
-- On GET reduce production expression -> CST 
-- On EQ reduce production expression -> CST 
-- On END reduce production expression -> CST 
-- On DOTS2 reduce production expression -> CST 
-- On DIV reduce production expression -> CST 
-- On BXOR reduce production expression -> CST 
-- On BOR reduce production expression -> CST 
-- On BNEQ reduce production expression -> CST 
-- On BAND reduce production expression -> CST 
-- On AND reduce production expression -> CST 
-- On ADD reduce production expression -> CST 

State 15:
expression -> BOOL_CST . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> BOOL_CST 
-- On SUB reduce production expression -> BOOL_CST 
-- On SEPARATOR reduce production expression -> BOOL_CST 
-- On SEMI reduce production expression -> BOOL_CST 
-- On RPAR reduce production expression -> BOOL_CST 
-- On OR reduce production expression -> BOOL_CST 
-- On NEQ reduce production expression -> BOOL_CST 
-- On MUL reduce production expression -> BOOL_CST 
-- On MOD reduce production expression -> BOOL_CST 
-- On LT reduce production expression -> BOOL_CST 
-- On LET reduce production expression -> BOOL_CST 
-- On GT reduce production expression -> BOOL_CST 
-- On GET reduce production expression -> BOOL_CST 
-- On EQ reduce production expression -> BOOL_CST 
-- On END reduce production expression -> BOOL_CST 
-- On DOTS2 reduce production expression -> BOOL_CST 
-- On DIV reduce production expression -> BOOL_CST 
-- On BXOR reduce production expression -> BOOL_CST 
-- On BOR reduce production expression -> BOOL_CST 
-- On BNEQ reduce production expression -> BOOL_CST 
-- On BAND reduce production expression -> BOOL_CST 
-- On AND reduce production expression -> BOOL_CST 
-- On ADD reduce production expression -> BOOL_CST 

State 16:
expression -> int_op . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> int_op 
-- On SUB reduce production expression -> int_op 
-- On SEPARATOR reduce production expression -> int_op 
-- On SEMI reduce production expression -> int_op 
-- On RPAR reduce production expression -> int_op 
-- On OR reduce production expression -> int_op 
-- On NEQ reduce production expression -> int_op 
-- On MUL reduce production expression -> int_op 
-- On MOD reduce production expression -> int_op 
-- On LT reduce production expression -> int_op 
-- On LET reduce production expression -> int_op 
-- On GT reduce production expression -> int_op 
-- On GET reduce production expression -> int_op 
-- On EQ reduce production expression -> int_op 
-- On END reduce production expression -> int_op 
-- On DOTS2 reduce production expression -> int_op 
-- On DIV reduce production expression -> int_op 
-- On BXOR reduce production expression -> int_op 
-- On BOR reduce production expression -> int_op 
-- On BNEQ reduce production expression -> int_op 
-- On BAND reduce production expression -> int_op 
-- On AND reduce production expression -> int_op 
-- On ADD reduce production expression -> int_op 

State 17:
expression -> IDENT LPAR funcall_args . RPAR [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On RPAR shift to state 18

State 18:
expression -> IDENT LPAR funcall_args RPAR . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On SUB reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On SEPARATOR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On SEMI reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On RPAR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On OR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On NEQ reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On MUL reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On MOD reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On LT reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On LET reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On GT reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On GET reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On EQ reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On END reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On DOTS2 reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On DIV reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On BXOR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On BOR reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On BNEQ reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On BAND reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On AND reduce production expression -> IDENT LPAR funcall_args RPAR 
-- On ADD reduce production expression -> IDENT LPAR funcall_args RPAR 

State 19:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
funcall_args -> expression . [ RPAR ]
funcall_args -> expression . SEPARATOR funcall_args [ RPAR ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On SEPARATOR shift to state 57
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On RPAR reduce production funcall_args -> expression 

State 20:
bool_op -> expression XOR . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 21
-- On bool_op shift to state 56

State 21:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression XOR expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression XOR expression 
-- On SUB reduce production bool_op -> expression XOR expression 
-- On SEPARATOR reduce production bool_op -> expression XOR expression 
-- On SEMI reduce production bool_op -> expression XOR expression 
-- On RPAR reduce production bool_op -> expression XOR expression 
-- On OR reduce production bool_op -> expression XOR expression 
-- On NEQ reduce production bool_op -> expression XOR expression 
-- On MUL reduce production bool_op -> expression XOR expression 
-- On MOD reduce production bool_op -> expression XOR expression 
-- On LT reduce production bool_op -> expression XOR expression 
-- On LET reduce production bool_op -> expression XOR expression 
-- On GT reduce production bool_op -> expression XOR expression 
-- On GET reduce production bool_op -> expression XOR expression 
-- On EQ reduce production bool_op -> expression XOR expression 
-- On END reduce production bool_op -> expression XOR expression 
-- On DOTS2 reduce production bool_op -> expression XOR expression 
-- On DIV reduce production bool_op -> expression XOR expression 
-- On BXOR reduce production bool_op -> expression XOR expression 
-- On BOR reduce production bool_op -> expression XOR expression 
-- On BNEQ reduce production bool_op -> expression XOR expression 
-- On BAND reduce production bool_op -> expression XOR expression 
-- On AND reduce production bool_op -> expression XOR expression 
-- On ADD reduce production bool_op -> expression XOR expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 22:
int_op -> expression SUB . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 23
-- On bool_op shift to state 56

State 23:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression SUB expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production int_op -> expression SUB expression 
-- On SUB reduce production int_op -> expression SUB expression 
-- On SEPARATOR reduce production int_op -> expression SUB expression 
-- On SEMI reduce production int_op -> expression SUB expression 
-- On RPAR reduce production int_op -> expression SUB expression 
-- On OR reduce production int_op -> expression SUB expression 
-- On NEQ reduce production int_op -> expression SUB expression 
-- On MUL reduce production int_op -> expression SUB expression 
-- On MOD reduce production int_op -> expression SUB expression 
-- On LT reduce production int_op -> expression SUB expression 
-- On LET reduce production int_op -> expression SUB expression 
-- On GT reduce production int_op -> expression SUB expression 
-- On GET reduce production int_op -> expression SUB expression 
-- On EQ reduce production int_op -> expression SUB expression 
-- On END reduce production int_op -> expression SUB expression 
-- On DOTS2 reduce production int_op -> expression SUB expression 
-- On DIV reduce production int_op -> expression SUB expression 
-- On BXOR reduce production int_op -> expression SUB expression 
-- On BOR reduce production int_op -> expression SUB expression 
-- On BNEQ reduce production int_op -> expression SUB expression 
-- On BAND reduce production int_op -> expression SUB expression 
-- On AND reduce production int_op -> expression SUB expression 
-- On ADD reduce production int_op -> expression SUB expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 24:
bool_op -> expression OR . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 25
-- On bool_op shift to state 56

State 25:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression OR expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression OR expression 
-- On SUB reduce production bool_op -> expression OR expression 
-- On SEPARATOR reduce production bool_op -> expression OR expression 
-- On SEMI reduce production bool_op -> expression OR expression 
-- On RPAR reduce production bool_op -> expression OR expression 
-- On OR reduce production bool_op -> expression OR expression 
-- On NEQ reduce production bool_op -> expression OR expression 
-- On MUL reduce production bool_op -> expression OR expression 
-- On MOD reduce production bool_op -> expression OR expression 
-- On LT reduce production bool_op -> expression OR expression 
-- On LET reduce production bool_op -> expression OR expression 
-- On GT reduce production bool_op -> expression OR expression 
-- On GET reduce production bool_op -> expression OR expression 
-- On EQ reduce production bool_op -> expression OR expression 
-- On END reduce production bool_op -> expression OR expression 
-- On DOTS2 reduce production bool_op -> expression OR expression 
-- On DIV reduce production bool_op -> expression OR expression 
-- On BXOR reduce production bool_op -> expression OR expression 
-- On BOR reduce production bool_op -> expression OR expression 
-- On BNEQ reduce production bool_op -> expression OR expression 
-- On BAND reduce production bool_op -> expression OR expression 
-- On AND reduce production bool_op -> expression OR expression 
-- On ADD reduce production bool_op -> expression OR expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 26:
bool_op -> expression NEQ . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 27
-- On bool_op shift to state 56

State 27:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression NEQ expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression NEQ expression 
-- On SUB reduce production bool_op -> expression NEQ expression 
-- On SEPARATOR reduce production bool_op -> expression NEQ expression 
-- On SEMI reduce production bool_op -> expression NEQ expression 
-- On RPAR reduce production bool_op -> expression NEQ expression 
-- On OR reduce production bool_op -> expression NEQ expression 
-- On NEQ reduce production bool_op -> expression NEQ expression 
-- On MUL reduce production bool_op -> expression NEQ expression 
-- On MOD reduce production bool_op -> expression NEQ expression 
-- On LT reduce production bool_op -> expression NEQ expression 
-- On LET reduce production bool_op -> expression NEQ expression 
-- On GT reduce production bool_op -> expression NEQ expression 
-- On GET reduce production bool_op -> expression NEQ expression 
-- On EQ reduce production bool_op -> expression NEQ expression 
-- On END reduce production bool_op -> expression NEQ expression 
-- On DOTS2 reduce production bool_op -> expression NEQ expression 
-- On DIV reduce production bool_op -> expression NEQ expression 
-- On BXOR reduce production bool_op -> expression NEQ expression 
-- On BOR reduce production bool_op -> expression NEQ expression 
-- On BNEQ reduce production bool_op -> expression NEQ expression 
-- On BAND reduce production bool_op -> expression NEQ expression 
-- On AND reduce production bool_op -> expression NEQ expression 
-- On ADD reduce production bool_op -> expression NEQ expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 28:
int_op -> expression MUL . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 29
-- On bool_op shift to state 56

State 29:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression MUL expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production int_op -> expression MUL expression 
-- On SUB reduce production int_op -> expression MUL expression 
-- On SEPARATOR reduce production int_op -> expression MUL expression 
-- On SEMI reduce production int_op -> expression MUL expression 
-- On RPAR reduce production int_op -> expression MUL expression 
-- On OR reduce production int_op -> expression MUL expression 
-- On NEQ reduce production int_op -> expression MUL expression 
-- On MUL reduce production int_op -> expression MUL expression 
-- On MOD reduce production int_op -> expression MUL expression 
-- On LT reduce production int_op -> expression MUL expression 
-- On LET reduce production int_op -> expression MUL expression 
-- On GT reduce production int_op -> expression MUL expression 
-- On GET reduce production int_op -> expression MUL expression 
-- On EQ reduce production int_op -> expression MUL expression 
-- On END reduce production int_op -> expression MUL expression 
-- On DOTS2 reduce production int_op -> expression MUL expression 
-- On DIV reduce production int_op -> expression MUL expression 
-- On BXOR reduce production int_op -> expression MUL expression 
-- On BOR reduce production int_op -> expression MUL expression 
-- On BNEQ reduce production int_op -> expression MUL expression 
-- On BAND reduce production int_op -> expression MUL expression 
-- On AND reduce production int_op -> expression MUL expression 
-- On ADD reduce production int_op -> expression MUL expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 30:
int_op -> expression MOD . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 31
-- On bool_op shift to state 56

State 31:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression MOD expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production int_op -> expression MOD expression 
-- On SUB reduce production int_op -> expression MOD expression 
-- On SEPARATOR reduce production int_op -> expression MOD expression 
-- On SEMI reduce production int_op -> expression MOD expression 
-- On RPAR reduce production int_op -> expression MOD expression 
-- On OR reduce production int_op -> expression MOD expression 
-- On NEQ reduce production int_op -> expression MOD expression 
-- On MUL reduce production int_op -> expression MOD expression 
-- On MOD reduce production int_op -> expression MOD expression 
-- On LT reduce production int_op -> expression MOD expression 
-- On LET reduce production int_op -> expression MOD expression 
-- On GT reduce production int_op -> expression MOD expression 
-- On GET reduce production int_op -> expression MOD expression 
-- On EQ reduce production int_op -> expression MOD expression 
-- On END reduce production int_op -> expression MOD expression 
-- On DOTS2 reduce production int_op -> expression MOD expression 
-- On DIV reduce production int_op -> expression MOD expression 
-- On BXOR reduce production int_op -> expression MOD expression 
-- On BOR reduce production int_op -> expression MOD expression 
-- On BNEQ reduce production int_op -> expression MOD expression 
-- On BAND reduce production int_op -> expression MOD expression 
-- On AND reduce production int_op -> expression MOD expression 
-- On ADD reduce production int_op -> expression MOD expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 32:
bool_op -> expression LT . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 33
-- On bool_op shift to state 56

State 33:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression LT expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression LT expression 
-- On SUB reduce production bool_op -> expression LT expression 
-- On SEPARATOR reduce production bool_op -> expression LT expression 
-- On SEMI reduce production bool_op -> expression LT expression 
-- On RPAR reduce production bool_op -> expression LT expression 
-- On OR reduce production bool_op -> expression LT expression 
-- On NEQ reduce production bool_op -> expression LT expression 
-- On MUL reduce production bool_op -> expression LT expression 
-- On MOD reduce production bool_op -> expression LT expression 
-- On LT reduce production bool_op -> expression LT expression 
-- On LET reduce production bool_op -> expression LT expression 
-- On GT reduce production bool_op -> expression LT expression 
-- On GET reduce production bool_op -> expression LT expression 
-- On EQ reduce production bool_op -> expression LT expression 
-- On END reduce production bool_op -> expression LT expression 
-- On DOTS2 reduce production bool_op -> expression LT expression 
-- On DIV reduce production bool_op -> expression LT expression 
-- On BXOR reduce production bool_op -> expression LT expression 
-- On BOR reduce production bool_op -> expression LT expression 
-- On BNEQ reduce production bool_op -> expression LT expression 
-- On BAND reduce production bool_op -> expression LT expression 
-- On AND reduce production bool_op -> expression LT expression 
-- On ADD reduce production bool_op -> expression LT expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 34:
bool_op -> expression LET . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 35
-- On bool_op shift to state 56

State 35:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression LET expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression LET expression 
-- On SUB reduce production bool_op -> expression LET expression 
-- On SEPARATOR reduce production bool_op -> expression LET expression 
-- On SEMI reduce production bool_op -> expression LET expression 
-- On RPAR reduce production bool_op -> expression LET expression 
-- On OR reduce production bool_op -> expression LET expression 
-- On NEQ reduce production bool_op -> expression LET expression 
-- On MUL reduce production bool_op -> expression LET expression 
-- On MOD reduce production bool_op -> expression LET expression 
-- On LT reduce production bool_op -> expression LET expression 
-- On LET reduce production bool_op -> expression LET expression 
-- On GT reduce production bool_op -> expression LET expression 
-- On GET reduce production bool_op -> expression LET expression 
-- On EQ reduce production bool_op -> expression LET expression 
-- On END reduce production bool_op -> expression LET expression 
-- On DOTS2 reduce production bool_op -> expression LET expression 
-- On DIV reduce production bool_op -> expression LET expression 
-- On BXOR reduce production bool_op -> expression LET expression 
-- On BOR reduce production bool_op -> expression LET expression 
-- On BNEQ reduce production bool_op -> expression LET expression 
-- On BAND reduce production bool_op -> expression LET expression 
-- On AND reduce production bool_op -> expression LET expression 
-- On ADD reduce production bool_op -> expression LET expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 36:
bool_op -> expression GT . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 37
-- On bool_op shift to state 56

State 37:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression GT expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression GT expression 
-- On SUB reduce production bool_op -> expression GT expression 
-- On SEPARATOR reduce production bool_op -> expression GT expression 
-- On SEMI reduce production bool_op -> expression GT expression 
-- On RPAR reduce production bool_op -> expression GT expression 
-- On OR reduce production bool_op -> expression GT expression 
-- On NEQ reduce production bool_op -> expression GT expression 
-- On MUL reduce production bool_op -> expression GT expression 
-- On MOD reduce production bool_op -> expression GT expression 
-- On LT reduce production bool_op -> expression GT expression 
-- On LET reduce production bool_op -> expression GT expression 
-- On GT reduce production bool_op -> expression GT expression 
-- On GET reduce production bool_op -> expression GT expression 
-- On EQ reduce production bool_op -> expression GT expression 
-- On END reduce production bool_op -> expression GT expression 
-- On DOTS2 reduce production bool_op -> expression GT expression 
-- On DIV reduce production bool_op -> expression GT expression 
-- On BXOR reduce production bool_op -> expression GT expression 
-- On BOR reduce production bool_op -> expression GT expression 
-- On BNEQ reduce production bool_op -> expression GT expression 
-- On BAND reduce production bool_op -> expression GT expression 
-- On AND reduce production bool_op -> expression GT expression 
-- On ADD reduce production bool_op -> expression GT expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 38:
bool_op -> expression GET . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 39
-- On bool_op shift to state 56

State 39:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression GET expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression GET expression 
-- On SUB reduce production bool_op -> expression GET expression 
-- On SEPARATOR reduce production bool_op -> expression GET expression 
-- On SEMI reduce production bool_op -> expression GET expression 
-- On RPAR reduce production bool_op -> expression GET expression 
-- On OR reduce production bool_op -> expression GET expression 
-- On NEQ reduce production bool_op -> expression GET expression 
-- On MUL reduce production bool_op -> expression GET expression 
-- On MOD reduce production bool_op -> expression GET expression 
-- On LT reduce production bool_op -> expression GET expression 
-- On LET reduce production bool_op -> expression GET expression 
-- On GT reduce production bool_op -> expression GET expression 
-- On GET reduce production bool_op -> expression GET expression 
-- On EQ reduce production bool_op -> expression GET expression 
-- On END reduce production bool_op -> expression GET expression 
-- On DOTS2 reduce production bool_op -> expression GET expression 
-- On DIV reduce production bool_op -> expression GET expression 
-- On BXOR reduce production bool_op -> expression GET expression 
-- On BOR reduce production bool_op -> expression GET expression 
-- On BNEQ reduce production bool_op -> expression GET expression 
-- On BAND reduce production bool_op -> expression GET expression 
-- On AND reduce production bool_op -> expression GET expression 
-- On ADD reduce production bool_op -> expression GET expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 40:
bool_op -> expression EQ . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 41
-- On bool_op shift to state 56

State 41:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression EQ expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression EQ expression 
-- On SUB reduce production bool_op -> expression EQ expression 
-- On SEPARATOR reduce production bool_op -> expression EQ expression 
-- On SEMI reduce production bool_op -> expression EQ expression 
-- On RPAR reduce production bool_op -> expression EQ expression 
-- On OR reduce production bool_op -> expression EQ expression 
-- On NEQ reduce production bool_op -> expression EQ expression 
-- On MUL reduce production bool_op -> expression EQ expression 
-- On MOD reduce production bool_op -> expression EQ expression 
-- On LT reduce production bool_op -> expression EQ expression 
-- On LET reduce production bool_op -> expression EQ expression 
-- On GT reduce production bool_op -> expression EQ expression 
-- On GET reduce production bool_op -> expression EQ expression 
-- On EQ reduce production bool_op -> expression EQ expression 
-- On END reduce production bool_op -> expression EQ expression 
-- On DOTS2 reduce production bool_op -> expression EQ expression 
-- On DIV reduce production bool_op -> expression EQ expression 
-- On BXOR reduce production bool_op -> expression EQ expression 
-- On BOR reduce production bool_op -> expression EQ expression 
-- On BNEQ reduce production bool_op -> expression EQ expression 
-- On BAND reduce production bool_op -> expression EQ expression 
-- On AND reduce production bool_op -> expression EQ expression 
-- On ADD reduce production bool_op -> expression EQ expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 42:
int_op -> expression DIV . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 43
-- On bool_op shift to state 56

State 43:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression DIV expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production int_op -> expression DIV expression 
-- On SUB reduce production int_op -> expression DIV expression 
-- On SEPARATOR reduce production int_op -> expression DIV expression 
-- On SEMI reduce production int_op -> expression DIV expression 
-- On RPAR reduce production int_op -> expression DIV expression 
-- On OR reduce production int_op -> expression DIV expression 
-- On NEQ reduce production int_op -> expression DIV expression 
-- On MUL reduce production int_op -> expression DIV expression 
-- On MOD reduce production int_op -> expression DIV expression 
-- On LT reduce production int_op -> expression DIV expression 
-- On LET reduce production int_op -> expression DIV expression 
-- On GT reduce production int_op -> expression DIV expression 
-- On GET reduce production int_op -> expression DIV expression 
-- On EQ reduce production int_op -> expression DIV expression 
-- On END reduce production int_op -> expression DIV expression 
-- On DOTS2 reduce production int_op -> expression DIV expression 
-- On DIV reduce production int_op -> expression DIV expression 
-- On BXOR reduce production int_op -> expression DIV expression 
-- On BOR reduce production int_op -> expression DIV expression 
-- On BNEQ reduce production int_op -> expression DIV expression 
-- On BAND reduce production int_op -> expression DIV expression 
-- On AND reduce production int_op -> expression DIV expression 
-- On ADD reduce production int_op -> expression DIV expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 44:
bool_op -> expression BXOR . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 45
-- On bool_op shift to state 56

State 45:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression BXOR expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression BXOR expression 
-- On SUB reduce production bool_op -> expression BXOR expression 
-- On SEPARATOR reduce production bool_op -> expression BXOR expression 
-- On SEMI reduce production bool_op -> expression BXOR expression 
-- On RPAR reduce production bool_op -> expression BXOR expression 
-- On OR reduce production bool_op -> expression BXOR expression 
-- On NEQ reduce production bool_op -> expression BXOR expression 
-- On MUL reduce production bool_op -> expression BXOR expression 
-- On MOD reduce production bool_op -> expression BXOR expression 
-- On LT reduce production bool_op -> expression BXOR expression 
-- On LET reduce production bool_op -> expression BXOR expression 
-- On GT reduce production bool_op -> expression BXOR expression 
-- On GET reduce production bool_op -> expression BXOR expression 
-- On EQ reduce production bool_op -> expression BXOR expression 
-- On END reduce production bool_op -> expression BXOR expression 
-- On DOTS2 reduce production bool_op -> expression BXOR expression 
-- On DIV reduce production bool_op -> expression BXOR expression 
-- On BXOR reduce production bool_op -> expression BXOR expression 
-- On BOR reduce production bool_op -> expression BXOR expression 
-- On BNEQ reduce production bool_op -> expression BXOR expression 
-- On BAND reduce production bool_op -> expression BXOR expression 
-- On AND reduce production bool_op -> expression BXOR expression 
-- On ADD reduce production bool_op -> expression BXOR expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 46:
bool_op -> expression BOR . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 47
-- On bool_op shift to state 56

State 47:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression BOR expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression BOR expression 
-- On SUB reduce production bool_op -> expression BOR expression 
-- On SEPARATOR reduce production bool_op -> expression BOR expression 
-- On SEMI reduce production bool_op -> expression BOR expression 
-- On RPAR reduce production bool_op -> expression BOR expression 
-- On OR reduce production bool_op -> expression BOR expression 
-- On NEQ reduce production bool_op -> expression BOR expression 
-- On MUL reduce production bool_op -> expression BOR expression 
-- On MOD reduce production bool_op -> expression BOR expression 
-- On LT reduce production bool_op -> expression BOR expression 
-- On LET reduce production bool_op -> expression BOR expression 
-- On GT reduce production bool_op -> expression BOR expression 
-- On GET reduce production bool_op -> expression BOR expression 
-- On EQ reduce production bool_op -> expression BOR expression 
-- On END reduce production bool_op -> expression BOR expression 
-- On DOTS2 reduce production bool_op -> expression BOR expression 
-- On DIV reduce production bool_op -> expression BOR expression 
-- On BXOR reduce production bool_op -> expression BOR expression 
-- On BOR reduce production bool_op -> expression BOR expression 
-- On BNEQ reduce production bool_op -> expression BOR expression 
-- On BAND reduce production bool_op -> expression BOR expression 
-- On AND reduce production bool_op -> expression BOR expression 
-- On ADD reduce production bool_op -> expression BOR expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 48:
bool_op -> expression BNEQ . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 49
-- On bool_op shift to state 56

State 49:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression BNEQ expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression BNEQ expression 
-- On SUB reduce production bool_op -> expression BNEQ expression 
-- On SEPARATOR reduce production bool_op -> expression BNEQ expression 
-- On SEMI reduce production bool_op -> expression BNEQ expression 
-- On RPAR reduce production bool_op -> expression BNEQ expression 
-- On OR reduce production bool_op -> expression BNEQ expression 
-- On NEQ reduce production bool_op -> expression BNEQ expression 
-- On MUL reduce production bool_op -> expression BNEQ expression 
-- On MOD reduce production bool_op -> expression BNEQ expression 
-- On LT reduce production bool_op -> expression BNEQ expression 
-- On LET reduce production bool_op -> expression BNEQ expression 
-- On GT reduce production bool_op -> expression BNEQ expression 
-- On GET reduce production bool_op -> expression BNEQ expression 
-- On EQ reduce production bool_op -> expression BNEQ expression 
-- On END reduce production bool_op -> expression BNEQ expression 
-- On DOTS2 reduce production bool_op -> expression BNEQ expression 
-- On DIV reduce production bool_op -> expression BNEQ expression 
-- On BXOR reduce production bool_op -> expression BNEQ expression 
-- On BOR reduce production bool_op -> expression BNEQ expression 
-- On BNEQ reduce production bool_op -> expression BNEQ expression 
-- On BAND reduce production bool_op -> expression BNEQ expression 
-- On AND reduce production bool_op -> expression BNEQ expression 
-- On ADD reduce production bool_op -> expression BNEQ expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 50:
bool_op -> expression BAND . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 51
-- On bool_op shift to state 56

State 51:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression BAND expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression BAND expression 
-- On SUB reduce production bool_op -> expression BAND expression 
-- On SEPARATOR reduce production bool_op -> expression BAND expression 
-- On SEMI reduce production bool_op -> expression BAND expression 
-- On RPAR reduce production bool_op -> expression BAND expression 
-- On OR reduce production bool_op -> expression BAND expression 
-- On NEQ reduce production bool_op -> expression BAND expression 
-- On MUL reduce production bool_op -> expression BAND expression 
-- On MOD reduce production bool_op -> expression BAND expression 
-- On LT reduce production bool_op -> expression BAND expression 
-- On LET reduce production bool_op -> expression BAND expression 
-- On GT reduce production bool_op -> expression BAND expression 
-- On GET reduce production bool_op -> expression BAND expression 
-- On EQ reduce production bool_op -> expression BAND expression 
-- On END reduce production bool_op -> expression BAND expression 
-- On DOTS2 reduce production bool_op -> expression BAND expression 
-- On DIV reduce production bool_op -> expression BAND expression 
-- On BXOR reduce production bool_op -> expression BAND expression 
-- On BOR reduce production bool_op -> expression BAND expression 
-- On BNEQ reduce production bool_op -> expression BAND expression 
-- On BAND reduce production bool_op -> expression BAND expression 
-- On AND reduce production bool_op -> expression BAND expression 
-- On ADD reduce production bool_op -> expression BAND expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 52:
bool_op -> expression AND . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 53
-- On bool_op shift to state 56

State 53:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression AND expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production bool_op -> expression AND expression 
-- On SUB reduce production bool_op -> expression AND expression 
-- On SEPARATOR reduce production bool_op -> expression AND expression 
-- On SEMI reduce production bool_op -> expression AND expression 
-- On RPAR reduce production bool_op -> expression AND expression 
-- On OR reduce production bool_op -> expression AND expression 
-- On NEQ reduce production bool_op -> expression AND expression 
-- On MUL reduce production bool_op -> expression AND expression 
-- On MOD reduce production bool_op -> expression AND expression 
-- On LT reduce production bool_op -> expression AND expression 
-- On LET reduce production bool_op -> expression AND expression 
-- On GT reduce production bool_op -> expression AND expression 
-- On GET reduce production bool_op -> expression AND expression 
-- On EQ reduce production bool_op -> expression AND expression 
-- On END reduce production bool_op -> expression AND expression 
-- On DOTS2 reduce production bool_op -> expression AND expression 
-- On DIV reduce production bool_op -> expression AND expression 
-- On BXOR reduce production bool_op -> expression AND expression 
-- On BOR reduce production bool_op -> expression AND expression 
-- On BNEQ reduce production bool_op -> expression AND expression 
-- On BAND reduce production bool_op -> expression AND expression 
-- On AND reduce production bool_op -> expression AND expression 
-- On ADD reduce production bool_op -> expression AND expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 54:
int_op -> expression ADD . expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 55
-- On bool_op shift to state 56

State 55:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression ADD expression . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On XOR reduce production int_op -> expression ADD expression 
-- On SUB reduce production int_op -> expression ADD expression 
-- On SEPARATOR reduce production int_op -> expression ADD expression 
-- On SEMI reduce production int_op -> expression ADD expression 
-- On RPAR reduce production int_op -> expression ADD expression 
-- On OR reduce production int_op -> expression ADD expression 
-- On NEQ reduce production int_op -> expression ADD expression 
-- On MUL reduce production int_op -> expression ADD expression 
-- On MOD reduce production int_op -> expression ADD expression 
-- On LT reduce production int_op -> expression ADD expression 
-- On LET reduce production int_op -> expression ADD expression 
-- On GT reduce production int_op -> expression ADD expression 
-- On GET reduce production int_op -> expression ADD expression 
-- On EQ reduce production int_op -> expression ADD expression 
-- On END reduce production int_op -> expression ADD expression 
-- On DOTS2 reduce production int_op -> expression ADD expression 
-- On DIV reduce production int_op -> expression ADD expression 
-- On BXOR reduce production int_op -> expression ADD expression 
-- On BOR reduce production int_op -> expression ADD expression 
-- On BNEQ reduce production int_op -> expression ADD expression 
-- On BAND reduce production int_op -> expression ADD expression 
-- On AND reduce production int_op -> expression ADD expression 
-- On ADD reduce production int_op -> expression ADD expression 
** Conflict on XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD

State 56:
expression -> bool_op . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> bool_op 
-- On SUB reduce production expression -> bool_op 
-- On SEPARATOR reduce production expression -> bool_op 
-- On SEMI reduce production expression -> bool_op 
-- On RPAR reduce production expression -> bool_op 
-- On OR reduce production expression -> bool_op 
-- On NEQ reduce production expression -> bool_op 
-- On MUL reduce production expression -> bool_op 
-- On MOD reduce production expression -> bool_op 
-- On LT reduce production expression -> bool_op 
-- On LET reduce production expression -> bool_op 
-- On GT reduce production expression -> bool_op 
-- On GET reduce production expression -> bool_op 
-- On EQ reduce production expression -> bool_op 
-- On END reduce production expression -> bool_op 
-- On DOTS2 reduce production expression -> bool_op 
-- On DIV reduce production expression -> bool_op 
-- On BXOR reduce production expression -> bool_op 
-- On BOR reduce production expression -> bool_op 
-- On BNEQ reduce production expression -> bool_op 
-- On BAND reduce production expression -> bool_op 
-- On AND reduce production expression -> bool_op 
-- On ADD reduce production expression -> bool_op 

State 57:
funcall_args -> expression SEPARATOR . funcall_args [ RPAR ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On funcall_args shift to state 58
-- On expression shift to state 19
-- On bool_op shift to state 56
-- On RPAR reduce production funcall_args -> 

State 58:
funcall_args -> expression SEPARATOR funcall_args . [ RPAR ]
-- On RPAR reduce production funcall_args -> expression SEPARATOR funcall_args 

State 59:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
expression -> LPAR expression . RPAR [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 60
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 60:
expression -> LPAR expression RPAR . [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ END DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR reduce production expression -> LPAR expression RPAR 
-- On SUB reduce production expression -> LPAR expression RPAR 
-- On SEPARATOR reduce production expression -> LPAR expression RPAR 
-- On SEMI reduce production expression -> LPAR expression RPAR 
-- On RPAR reduce production expression -> LPAR expression RPAR 
-- On OR reduce production expression -> LPAR expression RPAR 
-- On NEQ reduce production expression -> LPAR expression RPAR 
-- On MUL reduce production expression -> LPAR expression RPAR 
-- On MOD reduce production expression -> LPAR expression RPAR 
-- On LT reduce production expression -> LPAR expression RPAR 
-- On LET reduce production expression -> LPAR expression RPAR 
-- On GT reduce production expression -> LPAR expression RPAR 
-- On GET reduce production expression -> LPAR expression RPAR 
-- On EQ reduce production expression -> LPAR expression RPAR 
-- On END reduce production expression -> LPAR expression RPAR 
-- On DOTS2 reduce production expression -> LPAR expression RPAR 
-- On DIV reduce production expression -> LPAR expression RPAR 
-- On BXOR reduce production expression -> LPAR expression RPAR 
-- On BOR reduce production expression -> LPAR expression RPAR 
-- On BNEQ reduce production expression -> LPAR expression RPAR 
-- On BAND reduce production expression -> LPAR expression RPAR 
-- On AND reduce production expression -> LPAR expression RPAR 
-- On ADD reduce production expression -> LPAR expression RPAR 

State 61:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
variable_set -> IDENT SET expression . [ SEPARATOR SEMI RPAR ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On SEPARATOR reduce production variable_set -> IDENT SET expression 
-- On SEMI reduce production variable_set -> IDENT SET expression 
-- On RPAR reduce production variable_set -> IDENT SET expression 

State 62:
variable_set -> IDENT ADD . ADD [ SEPARATOR SEMI RPAR ]
-- On ADD shift to state 63

State 63:
variable_set -> IDENT ADD ADD . [ SEPARATOR SEMI RPAR ]
-- On SEPARATOR reduce production variable_set -> IDENT ADD ADD 
-- On SEMI reduce production variable_set -> IDENT ADD ADD 
-- On RPAR reduce production variable_set -> IDENT ADD ADD 

State 64:
typ -> BOOL . [ IDENT ]
-- On IDENT reduce production typ -> BOOL 

State 65:
variable_set -> ADD . ADD IDENT [ SEPARATOR SEMI RPAR ]
-- On ADD shift to state 66

State 66:
variable_set -> ADD ADD . IDENT [ SEPARATOR SEMI RPAR ]
-- On IDENT shift to state 67

State 67:
variable_set -> ADD ADD IDENT . [ SEPARATOR SEMI RPAR ]
-- On SEPARATOR reduce production variable_set -> ADD ADD IDENT 
-- On SEMI reduce production variable_set -> ADD ADD IDENT 
-- On RPAR reduce production variable_set -> ADD ADD IDENT 

State 68:
variable_decl_set -> variable_set . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR EOF END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 69

State 69:
variable_decl_set -> variable_set SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR EOF END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production variable_decl_set -> variable_set SEMI 
-- On VOID reduce production variable_decl_set -> variable_set SEMI 
-- On SWITCH reduce production variable_decl_set -> variable_set SEMI 
-- On SUB reduce production variable_decl_set -> variable_set SEMI 
-- On RETURN reduce production variable_decl_set -> variable_set SEMI 
-- On PUTCHAR reduce production variable_decl_set -> variable_set SEMI 
-- On INT reduce production variable_decl_set -> variable_set SEMI 
-- On IF reduce production variable_decl_set -> variable_set SEMI 
-- On IDENT reduce production variable_decl_set -> variable_set SEMI 
-- On FOR reduce production variable_decl_set -> variable_set SEMI 
-- On EOF reduce production variable_decl_set -> variable_set SEMI 
-- On END reduce production variable_decl_set -> variable_set SEMI 
-- On ELSE reduce production variable_decl_set -> variable_set SEMI 
-- On DO reduce production variable_decl_set -> variable_set SEMI 
-- On DEFAULT reduce production variable_decl_set -> variable_set SEMI 
-- On CONTINUE reduce production variable_decl_set -> variable_set SEMI 
-- On CASE reduce production variable_decl_set -> variable_set SEMI 
-- On BREAK reduce production variable_decl_set -> variable_set SEMI 
-- On BOOL reduce production variable_decl_set -> variable_set SEMI 
-- On BEGIN reduce production variable_decl_set -> variable_set SEMI 
-- On ADD reduce production variable_decl_set -> variable_set SEMI 

State 70:
global_scope_def -> variable_decl_set . [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On VOID reduce production global_scope_def -> variable_decl_set 
-- On SUB reduce production global_scope_def -> variable_decl_set 
-- On INT reduce production global_scope_def -> variable_decl_set 
-- On IDENT reduce production global_scope_def -> variable_decl_set 
-- On EOF reduce production global_scope_def -> variable_decl_set 
-- On BOOL reduce production global_scope_def -> variable_decl_set 
-- On ADD reduce production global_scope_def -> variable_decl_set 

State 71:
function_decl -> typ . IDENT LPAR parameter_list RPAR BEGIN list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
simple_var_decl -> typ . IDENT [ SEMI ]
variable_set -> typ . IDENT SET expression [ SEMI ]
-- On IDENT shift to state 72

State 72:
function_decl -> typ IDENT . LPAR parameter_list RPAR BEGIN list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
simple_var_decl -> typ IDENT . [ SEMI ]
variable_set -> typ IDENT . SET expression [ SEMI ]
-- On SET shift to state 73
-- On LPAR shift to state 75
-- On SEMI reduce production simple_var_decl -> typ IDENT 

State 73:
variable_set -> typ IDENT SET . expression [ SEPARATOR SEMI RPAR ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 74
-- On bool_op shift to state 56

State 74:
bool_op -> expression . LT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEPARATOR SEMI RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
variable_set -> typ IDENT SET expression . [ SEPARATOR SEMI RPAR ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54
-- On SEPARATOR reduce production variable_set -> typ IDENT SET expression 
-- On SEMI reduce production variable_set -> typ IDENT SET expression 
-- On RPAR reduce production variable_set -> typ IDENT SET expression 

State 75:
function_decl -> typ IDENT LPAR . parameter_list RPAR BEGIN list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On VOID shift to state 2
-- On INT shift to state 6
-- On BOOL shift to state 64
-- On typ shift to state 76
-- On simple_var_decl shift to state 78
-- On parameter_list shift to state 81
-- On RPAR reduce production parameter_list -> 

State 76:
simple_var_decl -> typ . IDENT [ SEPARATOR RPAR ]
-- On IDENT shift to state 77

State 77:
simple_var_decl -> typ IDENT . [ SEPARATOR RPAR ]
-- On SEPARATOR reduce production simple_var_decl -> typ IDENT 
-- On RPAR reduce production simple_var_decl -> typ IDENT 

State 78:
parameter_list -> simple_var_decl . [ RPAR ]
parameter_list -> simple_var_decl . SEPARATOR parameter_list [ RPAR ]
-- On SEPARATOR shift to state 79
-- On RPAR reduce production parameter_list -> simple_var_decl 

State 79:
parameter_list -> simple_var_decl SEPARATOR . parameter_list [ RPAR ]
-- On VOID shift to state 2
-- On INT shift to state 6
-- On BOOL shift to state 64
-- On typ shift to state 76
-- On simple_var_decl shift to state 78
-- On parameter_list shift to state 80
-- On RPAR reduce production parameter_list -> 

State 80:
parameter_list -> simple_var_decl SEPARATOR parameter_list . [ RPAR ]
-- On RPAR reduce production parameter_list -> simple_var_decl SEPARATOR parameter_list 

State 81:
function_decl -> typ IDENT LPAR parameter_list . RPAR BEGIN list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On RPAR shift to state 82

State 82:
function_decl -> typ IDENT LPAR parameter_list RPAR . BEGIN list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On BEGIN shift to state 83

State 83:
function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN . list(instruction) END [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 186
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 84:
loop -> WHILE . LPAR expression RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> WHILE . LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 85

State 85:
loop -> WHILE LPAR . expression RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> WHILE LPAR . expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 86
-- On bool_op shift to state 56

State 86:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
loop -> WHILE LPAR expression . RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> WHILE LPAR expression . RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 87
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 87:
loop -> WHILE LPAR expression RPAR . BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> WHILE LPAR expression RPAR . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 88
-- On BEGIN shift to state 89

State 88:
loop -> WHILE LPAR expression RPAR SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On VOID reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On SWITCH reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On SUB reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On RETURN reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On PUTCHAR reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On INT reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On IF reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On IDENT reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On FOR reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On END reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On ELSE reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On DO reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On DEFAULT reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On CONTINUE reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On CASE reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On BREAK reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On BOOL reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On BEGIN reduce production loop -> WHILE LPAR expression RPAR SEMI 
-- On ADD reduce production loop -> WHILE LPAR expression RPAR SEMI 

State 89:
loop -> WHILE LPAR expression RPAR BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 184
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 90:
conditional -> SWITCH . LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH . LPAR expression RPAR BEGIN block_case_list END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 91

State 91:
conditional -> SWITCH LPAR . expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH LPAR . expression RPAR BEGIN block_case_list END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 92
-- On bool_op shift to state 56

State 92:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
conditional -> SWITCH LPAR expression . RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH LPAR expression . RPAR BEGIN block_case_list END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 93
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 93:
conditional -> SWITCH LPAR expression RPAR . BEGIN block_case_list DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH LPAR expression RPAR . BEGIN block_case_list END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On BEGIN shift to state 94

State 94:
conditional -> SWITCH LPAR expression RPAR BEGIN . block_case_list DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH LPAR expression RPAR BEGIN . block_case_list END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On CASE shift to state 95
-- On expr_case_list shift to state 99
-- On block_case_list shift to state 178
-- On END reduce production block_case_list -> 
-- On DEFAULT reduce production block_case_list -> 

State 95:
expr_case_list -> CASE . expression DOTS2 [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
expr_case_list -> CASE . expression DOTS2 expr_case_list [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 96
-- On bool_op shift to state 56

State 96:
bool_op -> expression . LT expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
expr_case_list -> CASE expression . DOTS2 [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
expr_case_list -> CASE expression . DOTS2 expr_case_list [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
int_op -> expression . ADD expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DOTS2 DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DOTS2 shift to state 97
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 97:
expr_case_list -> CASE expression DOTS2 . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
expr_case_list -> CASE expression DOTS2 . expr_case_list [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On CASE shift to state 95
-- On expr_case_list shift to state 98
-- On WHILE reduce production expr_case_list -> CASE expression DOTS2 
-- On VOID reduce production expr_case_list -> CASE expression DOTS2 
-- On SWITCH reduce production expr_case_list -> CASE expression DOTS2 
-- On SUB reduce production expr_case_list -> CASE expression DOTS2 
-- On RETURN reduce production expr_case_list -> CASE expression DOTS2 
-- On PUTCHAR reduce production expr_case_list -> CASE expression DOTS2 
-- On INT reduce production expr_case_list -> CASE expression DOTS2 
-- On IF reduce production expr_case_list -> CASE expression DOTS2 
-- On IDENT reduce production expr_case_list -> CASE expression DOTS2 
-- On FOR reduce production expr_case_list -> CASE expression DOTS2 
-- On END reduce production expr_case_list -> CASE expression DOTS2 
-- On DO reduce production expr_case_list -> CASE expression DOTS2 
-- On DEFAULT reduce production expr_case_list -> CASE expression DOTS2 
-- On CONTINUE reduce production expr_case_list -> CASE expression DOTS2 
-- On CASE reduce production expr_case_list -> CASE expression DOTS2 
-- On BREAK reduce production expr_case_list -> CASE expression DOTS2 
-- On BOOL reduce production expr_case_list -> CASE expression DOTS2 
-- On BEGIN reduce production expr_case_list -> CASE expression DOTS2 
-- On ADD reduce production expr_case_list -> CASE expression DOTS2 
** Conflict on CASE

State 98:
expr_case_list -> CASE expression DOTS2 expr_case_list . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On VOID reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On SWITCH reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On SUB reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On RETURN reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On PUTCHAR reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On INT reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On IF reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On IDENT reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On FOR reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On END reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On DO reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On DEFAULT reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On CONTINUE reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On CASE reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On BREAK reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On BOOL reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On BEGIN reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 
-- On ADD reduce production expr_case_list -> CASE expression DOTS2 expr_case_list 

State 99:
block_case_list -> expr_case_list . list(instruction) block_case_list [ END DEFAULT ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 176
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 
-- On DEFAULT reduce production list(instruction) -> 
-- On CASE reduce production list(instruction) -> 

State 100:
return -> RETURN . expression SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
return -> RETURN . BEGIN expression END SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
return -> RETURN . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 101
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On BEGIN shift to state 102
-- On int_op shift to state 16
-- On expression shift to state 106
-- On bool_op shift to state 56

State 101:
return -> RETURN SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production return -> RETURN SEMI 
-- On VOID reduce production return -> RETURN SEMI 
-- On SWITCH reduce production return -> RETURN SEMI 
-- On SUB reduce production return -> RETURN SEMI 
-- On RETURN reduce production return -> RETURN SEMI 
-- On PUTCHAR reduce production return -> RETURN SEMI 
-- On INT reduce production return -> RETURN SEMI 
-- On IF reduce production return -> RETURN SEMI 
-- On IDENT reduce production return -> RETURN SEMI 
-- On FOR reduce production return -> RETURN SEMI 
-- On END reduce production return -> RETURN SEMI 
-- On ELSE reduce production return -> RETURN SEMI 
-- On DO reduce production return -> RETURN SEMI 
-- On DEFAULT reduce production return -> RETURN SEMI 
-- On CONTINUE reduce production return -> RETURN SEMI 
-- On CASE reduce production return -> RETURN SEMI 
-- On BREAK reduce production return -> RETURN SEMI 
-- On BOOL reduce production return -> RETURN SEMI 
-- On BEGIN reduce production return -> RETURN SEMI 
-- On ADD reduce production return -> RETURN SEMI 

State 102:
return -> RETURN BEGIN . expression END SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 103
-- On bool_op shift to state 56

State 103:
bool_op -> expression . LT expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB OR NEQ MUL MOD LT LET GT GET EQ END DIV BXOR BOR BNEQ BAND AND ADD ]
return -> RETURN BEGIN expression . END SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On END shift to state 104
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 104:
return -> RETURN BEGIN expression END . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 105

State 105:
return -> RETURN BEGIN expression END SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production return -> RETURN BEGIN expression END SEMI 
-- On VOID reduce production return -> RETURN BEGIN expression END SEMI 
-- On SWITCH reduce production return -> RETURN BEGIN expression END SEMI 
-- On SUB reduce production return -> RETURN BEGIN expression END SEMI 
-- On RETURN reduce production return -> RETURN BEGIN expression END SEMI 
-- On PUTCHAR reduce production return -> RETURN BEGIN expression END SEMI 
-- On INT reduce production return -> RETURN BEGIN expression END SEMI 
-- On IF reduce production return -> RETURN BEGIN expression END SEMI 
-- On IDENT reduce production return -> RETURN BEGIN expression END SEMI 
-- On FOR reduce production return -> RETURN BEGIN expression END SEMI 
-- On END reduce production return -> RETURN BEGIN expression END SEMI 
-- On ELSE reduce production return -> RETURN BEGIN expression END SEMI 
-- On DO reduce production return -> RETURN BEGIN expression END SEMI 
-- On DEFAULT reduce production return -> RETURN BEGIN expression END SEMI 
-- On CONTINUE reduce production return -> RETURN BEGIN expression END SEMI 
-- On CASE reduce production return -> RETURN BEGIN expression END SEMI 
-- On BREAK reduce production return -> RETURN BEGIN expression END SEMI 
-- On BOOL reduce production return -> RETURN BEGIN expression END SEMI 
-- On BEGIN reduce production return -> RETURN BEGIN expression END SEMI 
-- On ADD reduce production return -> RETURN BEGIN expression END SEMI 

State 106:
bool_op -> expression . LT expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
return -> RETURN expression . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On SEMI shift to state 107
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 107:
return -> RETURN expression SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production return -> RETURN expression SEMI 
-- On VOID reduce production return -> RETURN expression SEMI 
-- On SWITCH reduce production return -> RETURN expression SEMI 
-- On SUB reduce production return -> RETURN expression SEMI 
-- On RETURN reduce production return -> RETURN expression SEMI 
-- On PUTCHAR reduce production return -> RETURN expression SEMI 
-- On INT reduce production return -> RETURN expression SEMI 
-- On IF reduce production return -> RETURN expression SEMI 
-- On IDENT reduce production return -> RETURN expression SEMI 
-- On FOR reduce production return -> RETURN expression SEMI 
-- On END reduce production return -> RETURN expression SEMI 
-- On ELSE reduce production return -> RETURN expression SEMI 
-- On DO reduce production return -> RETURN expression SEMI 
-- On DEFAULT reduce production return -> RETURN expression SEMI 
-- On CONTINUE reduce production return -> RETURN expression SEMI 
-- On CASE reduce production return -> RETURN expression SEMI 
-- On BREAK reduce production return -> RETURN expression SEMI 
-- On BOOL reduce production return -> RETURN expression SEMI 
-- On BEGIN reduce production return -> RETURN expression SEMI 
-- On ADD reduce production return -> RETURN expression SEMI 

State 108:
instruction -> PUTCHAR . LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 109

State 109:
instruction -> PUTCHAR LPAR . expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 110
-- On bool_op shift to state 56

State 110:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
instruction -> PUTCHAR LPAR expression . RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 111
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 111:
instruction -> PUTCHAR LPAR expression RPAR . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 112

State 112:
instruction -> PUTCHAR LPAR expression RPAR SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On VOID reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On SWITCH reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On SUB reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On RETURN reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On PUTCHAR reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On INT reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On IF reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On IDENT reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On FOR reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On END reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On ELSE reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On DO reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On DEFAULT reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On CONTINUE reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On CASE reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On BREAK reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On BOOL reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On BEGIN reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 
-- On ADD reduce production instruction -> PUTCHAR LPAR expression RPAR SEMI 

State 113:
conditional -> IF . LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF . LPAR expression RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF . LPAR expression RPAR instruction ELSE instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF . LPAR expression RPAR instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF . LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 114

State 114:
conditional -> IF LPAR . expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR . expression RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR . expression RPAR instruction ELSE instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR . expression RPAR instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR . expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 115
-- On bool_op shift to state 56

State 115:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
conditional -> IF LPAR expression . RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression . RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression . RPAR instruction ELSE instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression . RPAR instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression . RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 116
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 116:
conditional -> IF LPAR expression RPAR . BEGIN list(instruction) END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR . BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR . instruction ELSE instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR . instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On SEMI shift to state 117
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 166
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On instruction shift to state 173
-- On conditional shift to state 149

State 117:
conditional -> IF LPAR expression RPAR SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On VOID reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On SWITCH reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On SUB reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On RETURN reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On PUTCHAR reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On INT reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On IF reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On IDENT reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On FOR reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On END reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On ELSE reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On DO reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On DEFAULT reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On CONTINUE reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On CASE reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On BREAK reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On BOOL reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On BEGIN reduce production conditional -> IF LPAR expression RPAR SEMI 
-- On ADD reduce production conditional -> IF LPAR expression RPAR SEMI 

State 118:
loop -> FOR . LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> FOR . LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 119

State 119:
loop -> FOR LPAR . for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> FOR LPAR . for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 120
-- On typ shift to state 122
-- On for_seq shift to state 125
-- On SEMI reduce production for_seq -> 

State 120:
for_seq -> variable_set . [ SEMI RPAR ]
for_seq -> variable_set . SEPARATOR for_seq [ SEMI RPAR ]
-- On SEPARATOR shift to state 121
-- On SEMI reduce production for_seq -> variable_set 
-- On RPAR reduce production for_seq -> variable_set 

State 121:
for_seq -> variable_set SEPARATOR . for_seq [ SEMI RPAR ]
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 120
-- On typ shift to state 122
-- On for_seq shift to state 124
-- On SEMI reduce production for_seq -> 
-- On RPAR reduce production for_seq -> 

State 122:
variable_set -> typ . IDENT SET expression [ SEPARATOR SEMI RPAR ]
-- On IDENT shift to state 123

State 123:
variable_set -> typ IDENT . SET expression [ SEPARATOR SEMI RPAR ]
-- On SET shift to state 73

State 124:
for_seq -> variable_set SEPARATOR for_seq . [ SEMI RPAR ]
-- On SEMI reduce production for_seq -> variable_set SEPARATOR for_seq 
-- On RPAR reduce production for_seq -> variable_set SEPARATOR for_seq 

State 125:
loop -> FOR LPAR for_seq . SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> FOR LPAR for_seq . SEMI SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 126

State 126:
loop -> FOR LPAR for_seq SEMI . expression SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
loop -> FOR LPAR for_seq SEMI . SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 127
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 159
-- On bool_op shift to state 56

State 127:
loop -> FOR LPAR for_seq SEMI SEMI . for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 120
-- On typ shift to state 122
-- On for_seq shift to state 128
-- On RPAR reduce production for_seq -> 

State 128:
loop -> FOR LPAR for_seq SEMI SEMI for_seq . RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On RPAR shift to state 129

State 129:
loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR . BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On BEGIN shift to state 130

State 130:
loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 157
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 131:
loop -> DO . BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On BEGIN shift to state 132

State 132:
loop -> DO BEGIN . list(instruction) END WHILE LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 150
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 133:
instruction -> CONTINUE . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 134

State 134:
instruction -> CONTINUE SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> CONTINUE SEMI 
-- On VOID reduce production instruction -> CONTINUE SEMI 
-- On SWITCH reduce production instruction -> CONTINUE SEMI 
-- On SUB reduce production instruction -> CONTINUE SEMI 
-- On RETURN reduce production instruction -> CONTINUE SEMI 
-- On PUTCHAR reduce production instruction -> CONTINUE SEMI 
-- On INT reduce production instruction -> CONTINUE SEMI 
-- On IF reduce production instruction -> CONTINUE SEMI 
-- On IDENT reduce production instruction -> CONTINUE SEMI 
-- On FOR reduce production instruction -> CONTINUE SEMI 
-- On END reduce production instruction -> CONTINUE SEMI 
-- On ELSE reduce production instruction -> CONTINUE SEMI 
-- On DO reduce production instruction -> CONTINUE SEMI 
-- On DEFAULT reduce production instruction -> CONTINUE SEMI 
-- On CONTINUE reduce production instruction -> CONTINUE SEMI 
-- On CASE reduce production instruction -> CONTINUE SEMI 
-- On BREAK reduce production instruction -> CONTINUE SEMI 
-- On BOOL reduce production instruction -> CONTINUE SEMI 
-- On BEGIN reduce production instruction -> CONTINUE SEMI 
-- On ADD reduce production instruction -> CONTINUE SEMI 

State 135:
instruction -> BREAK . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 136

State 136:
instruction -> BREAK SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> BREAK SEMI 
-- On VOID reduce production instruction -> BREAK SEMI 
-- On SWITCH reduce production instruction -> BREAK SEMI 
-- On SUB reduce production instruction -> BREAK SEMI 
-- On RETURN reduce production instruction -> BREAK SEMI 
-- On PUTCHAR reduce production instruction -> BREAK SEMI 
-- On INT reduce production instruction -> BREAK SEMI 
-- On IF reduce production instruction -> BREAK SEMI 
-- On IDENT reduce production instruction -> BREAK SEMI 
-- On FOR reduce production instruction -> BREAK SEMI 
-- On END reduce production instruction -> BREAK SEMI 
-- On ELSE reduce production instruction -> BREAK SEMI 
-- On DO reduce production instruction -> BREAK SEMI 
-- On DEFAULT reduce production instruction -> BREAK SEMI 
-- On CONTINUE reduce production instruction -> BREAK SEMI 
-- On CASE reduce production instruction -> BREAK SEMI 
-- On BREAK reduce production instruction -> BREAK SEMI 
-- On BOOL reduce production instruction -> BREAK SEMI 
-- On BEGIN reduce production instruction -> BREAK SEMI 
-- On ADD reduce production instruction -> BREAK SEMI 

State 137:
instruction -> BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 145
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 138:
instruction -> variable_decl_set . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> variable_decl_set 
-- On VOID reduce production instruction -> variable_decl_set 
-- On SWITCH reduce production instruction -> variable_decl_set 
-- On SUB reduce production instruction -> variable_decl_set 
-- On RETURN reduce production instruction -> variable_decl_set 
-- On PUTCHAR reduce production instruction -> variable_decl_set 
-- On INT reduce production instruction -> variable_decl_set 
-- On IF reduce production instruction -> variable_decl_set 
-- On IDENT reduce production instruction -> variable_decl_set 
-- On FOR reduce production instruction -> variable_decl_set 
-- On END reduce production instruction -> variable_decl_set 
-- On ELSE reduce production instruction -> variable_decl_set 
-- On DO reduce production instruction -> variable_decl_set 
-- On DEFAULT reduce production instruction -> variable_decl_set 
-- On CONTINUE reduce production instruction -> variable_decl_set 
-- On CASE reduce production instruction -> variable_decl_set 
-- On BREAK reduce production instruction -> variable_decl_set 
-- On BOOL reduce production instruction -> variable_decl_set 
-- On BEGIN reduce production instruction -> variable_decl_set 
-- On ADD reduce production instruction -> variable_decl_set 

State 139:
simple_var_decl -> typ . IDENT [ SEMI ]
variable_set -> typ . IDENT SET expression [ SEMI ]
-- On IDENT shift to state 140

State 140:
simple_var_decl -> typ IDENT . [ SEMI ]
variable_set -> typ IDENT . SET expression [ SEMI ]
-- On SET shift to state 73
-- On SEMI reduce production simple_var_decl -> typ IDENT 

State 141:
variable_decl_set -> simple_var_decl . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR EOF END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 142

State 142:
variable_decl_set -> simple_var_decl SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR EOF END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production variable_decl_set -> simple_var_decl SEMI 
-- On VOID reduce production variable_decl_set -> simple_var_decl SEMI 
-- On SWITCH reduce production variable_decl_set -> simple_var_decl SEMI 
-- On SUB reduce production variable_decl_set -> simple_var_decl SEMI 
-- On RETURN reduce production variable_decl_set -> simple_var_decl SEMI 
-- On PUTCHAR reduce production variable_decl_set -> simple_var_decl SEMI 
-- On INT reduce production variable_decl_set -> simple_var_decl SEMI 
-- On IF reduce production variable_decl_set -> simple_var_decl SEMI 
-- On IDENT reduce production variable_decl_set -> simple_var_decl SEMI 
-- On FOR reduce production variable_decl_set -> simple_var_decl SEMI 
-- On EOF reduce production variable_decl_set -> simple_var_decl SEMI 
-- On END reduce production variable_decl_set -> simple_var_decl SEMI 
-- On ELSE reduce production variable_decl_set -> simple_var_decl SEMI 
-- On DO reduce production variable_decl_set -> simple_var_decl SEMI 
-- On DEFAULT reduce production variable_decl_set -> simple_var_decl SEMI 
-- On CONTINUE reduce production variable_decl_set -> simple_var_decl SEMI 
-- On CASE reduce production variable_decl_set -> simple_var_decl SEMI 
-- On BREAK reduce production variable_decl_set -> simple_var_decl SEMI 
-- On BOOL reduce production variable_decl_set -> simple_var_decl SEMI 
-- On BEGIN reduce production variable_decl_set -> simple_var_decl SEMI 
-- On ADD reduce production variable_decl_set -> simple_var_decl SEMI 

State 143:
instruction -> return . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> return 
-- On VOID reduce production instruction -> return 
-- On SWITCH reduce production instruction -> return 
-- On SUB reduce production instruction -> return 
-- On RETURN reduce production instruction -> return 
-- On PUTCHAR reduce production instruction -> return 
-- On INT reduce production instruction -> return 
-- On IF reduce production instruction -> return 
-- On IDENT reduce production instruction -> return 
-- On FOR reduce production instruction -> return 
-- On END reduce production instruction -> return 
-- On ELSE reduce production instruction -> return 
-- On DO reduce production instruction -> return 
-- On DEFAULT reduce production instruction -> return 
-- On CONTINUE reduce production instruction -> return 
-- On CASE reduce production instruction -> return 
-- On BREAK reduce production instruction -> return 
-- On BOOL reduce production instruction -> return 
-- On BEGIN reduce production instruction -> return 
-- On ADD reduce production instruction -> return 

State 144:
instruction -> loop . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> loop 
-- On VOID reduce production instruction -> loop 
-- On SWITCH reduce production instruction -> loop 
-- On SUB reduce production instruction -> loop 
-- On RETURN reduce production instruction -> loop 
-- On PUTCHAR reduce production instruction -> loop 
-- On INT reduce production instruction -> loop 
-- On IF reduce production instruction -> loop 
-- On IDENT reduce production instruction -> loop 
-- On FOR reduce production instruction -> loop 
-- On END reduce production instruction -> loop 
-- On ELSE reduce production instruction -> loop 
-- On DO reduce production instruction -> loop 
-- On DEFAULT reduce production instruction -> loop 
-- On CONTINUE reduce production instruction -> loop 
-- On CASE reduce production instruction -> loop 
-- On BREAK reduce production instruction -> loop 
-- On BOOL reduce production instruction -> loop 
-- On BEGIN reduce production instruction -> loop 
-- On ADD reduce production instruction -> loop 

State 145:
instruction -> BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 146

State 146:
instruction -> BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> BEGIN list(instruction) END 
-- On VOID reduce production instruction -> BEGIN list(instruction) END 
-- On SWITCH reduce production instruction -> BEGIN list(instruction) END 
-- On SUB reduce production instruction -> BEGIN list(instruction) END 
-- On RETURN reduce production instruction -> BEGIN list(instruction) END 
-- On PUTCHAR reduce production instruction -> BEGIN list(instruction) END 
-- On INT reduce production instruction -> BEGIN list(instruction) END 
-- On IF reduce production instruction -> BEGIN list(instruction) END 
-- On IDENT reduce production instruction -> BEGIN list(instruction) END 
-- On FOR reduce production instruction -> BEGIN list(instruction) END 
-- On END reduce production instruction -> BEGIN list(instruction) END 
-- On ELSE reduce production instruction -> BEGIN list(instruction) END 
-- On DO reduce production instruction -> BEGIN list(instruction) END 
-- On DEFAULT reduce production instruction -> BEGIN list(instruction) END 
-- On CONTINUE reduce production instruction -> BEGIN list(instruction) END 
-- On CASE reduce production instruction -> BEGIN list(instruction) END 
-- On BREAK reduce production instruction -> BEGIN list(instruction) END 
-- On BOOL reduce production instruction -> BEGIN list(instruction) END 
-- On BEGIN reduce production instruction -> BEGIN list(instruction) END 
-- On ADD reduce production instruction -> BEGIN list(instruction) END 

State 147:
list(instruction) -> instruction . list(instruction) [ END DEFAULT CASE ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 148
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 
-- On DEFAULT reduce production list(instruction) -> 
-- On CASE reduce production list(instruction) -> 

State 148:
list(instruction) -> instruction list(instruction) . [ END DEFAULT CASE ]
-- On END reduce production list(instruction) -> instruction list(instruction) 
-- On DEFAULT reduce production list(instruction) -> instruction list(instruction) 
-- On CASE reduce production list(instruction) -> instruction list(instruction) 

State 149:
instruction -> conditional . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production instruction -> conditional 
-- On VOID reduce production instruction -> conditional 
-- On SWITCH reduce production instruction -> conditional 
-- On SUB reduce production instruction -> conditional 
-- On RETURN reduce production instruction -> conditional 
-- On PUTCHAR reduce production instruction -> conditional 
-- On INT reduce production instruction -> conditional 
-- On IF reduce production instruction -> conditional 
-- On IDENT reduce production instruction -> conditional 
-- On FOR reduce production instruction -> conditional 
-- On END reduce production instruction -> conditional 
-- On ELSE reduce production instruction -> conditional 
-- On DO reduce production instruction -> conditional 
-- On DEFAULT reduce production instruction -> conditional 
-- On CONTINUE reduce production instruction -> conditional 
-- On CASE reduce production instruction -> conditional 
-- On BREAK reduce production instruction -> conditional 
-- On BOOL reduce production instruction -> conditional 
-- On BEGIN reduce production instruction -> conditional 
-- On ADD reduce production instruction -> conditional 

State 150:
loop -> DO BEGIN list(instruction) . END WHILE LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 151

State 151:
loop -> DO BEGIN list(instruction) END . WHILE LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 152

State 152:
loop -> DO BEGIN list(instruction) END WHILE . LPAR expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 153

State 153:
loop -> DO BEGIN list(instruction) END WHILE LPAR . expression RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On LPAR shift to state 11
-- On IDENT shift to state 12
-- On CST shift to state 14
-- On BOOL_CST shift to state 15
-- On int_op shift to state 16
-- On expression shift to state 154
-- On bool_op shift to state 56

State 154:
bool_op -> expression . LT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB RPAR OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
loop -> DO BEGIN list(instruction) END WHILE LPAR expression . RPAR SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On RPAR shift to state 155
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 155:
loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR . SEMI [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On SEMI shift to state 156

State 156:
loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On VOID reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On SWITCH reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On SUB reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On RETURN reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On PUTCHAR reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On INT reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On IF reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On IDENT reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On FOR reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On END reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On ELSE reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On DO reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On DEFAULT reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On CONTINUE reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On CASE reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On BREAK reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On BOOL reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On BEGIN reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 
-- On ADD reduce production loop -> DO BEGIN list(instruction) END WHILE LPAR expression RPAR SEMI 

State 157:
loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 158

State 158:
loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On VOID reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On SWITCH reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On SUB reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On RETURN reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On PUTCHAR reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On INT reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On IF reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On IDENT reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On FOR reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On END reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On ELSE reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On DO reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On DEFAULT reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On CONTINUE reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On CASE reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BREAK reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BOOL reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BEGIN reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 
-- On ADD reduce production loop -> FOR LPAR for_seq SEMI SEMI for_seq RPAR BEGIN list(instruction) END 

State 159:
bool_op -> expression . LT expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GT expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . LET expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . GET expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . EQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . AND expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BAND expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . OR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . XOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BXOR expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . NEQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
bool_op -> expression . BNEQ expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . ADD expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MUL expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . DIV expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . MOD expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
int_op -> expression . SUB expression [ XOR SUB SEMI OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD ]
loop -> FOR LPAR for_seq SEMI expression . SEMI for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On XOR shift to state 20
-- On SUB shift to state 22
-- On SEMI shift to state 160
-- On OR shift to state 24
-- On NEQ shift to state 26
-- On MUL shift to state 28
-- On MOD shift to state 30
-- On LT shift to state 32
-- On LET shift to state 34
-- On GT shift to state 36
-- On GET shift to state 38
-- On EQ shift to state 40
-- On DIV shift to state 42
-- On BXOR shift to state 44
-- On BOR shift to state 46
-- On BNEQ shift to state 48
-- On BAND shift to state 50
-- On AND shift to state 52
-- On ADD shift to state 54

State 160:
loop -> FOR LPAR for_seq SEMI expression SEMI . for_seq RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 120
-- On typ shift to state 122
-- On for_seq shift to state 161
-- On RPAR reduce production for_seq -> 

State 161:
loop -> FOR LPAR for_seq SEMI expression SEMI for_seq . RPAR BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On RPAR shift to state 162

State 162:
loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR . BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On BEGIN shift to state 163

State 163:
loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 164
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 164:
loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 165

State 165:
loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On VOID reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On SWITCH reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On SUB reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On RETURN reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On PUTCHAR reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On INT reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On IF reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On IDENT reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On FOR reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On END reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On ELSE reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On DO reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On DEFAULT reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On CONTINUE reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On CASE reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BREAK reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BOOL reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On BEGIN reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 
-- On ADD reduce production loop -> FOR LPAR for_seq SEMI expression SEMI for_seq RPAR BEGIN list(instruction) END 

State 166:
conditional -> IF LPAR expression RPAR BEGIN . list(instruction) END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
instruction -> BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 167
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 167:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) . END ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
instruction -> BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 168

State 168:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END . ELSE BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
instruction -> BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On ELSE shift to state 169
-- On WHILE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On WHILE reduce production instruction -> BEGIN list(instruction) END 
-- On VOID reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On VOID reduce production instruction -> BEGIN list(instruction) END 
-- On SWITCH reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On SWITCH reduce production instruction -> BEGIN list(instruction) END 
-- On SUB reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On SUB reduce production instruction -> BEGIN list(instruction) END 
-- On RETURN reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On RETURN reduce production instruction -> BEGIN list(instruction) END 
-- On PUTCHAR reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On PUTCHAR reduce production instruction -> BEGIN list(instruction) END 
-- On INT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On INT reduce production instruction -> BEGIN list(instruction) END 
-- On IF reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On IF reduce production instruction -> BEGIN list(instruction) END 
-- On IDENT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On IDENT reduce production instruction -> BEGIN list(instruction) END 
-- On FOR reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On FOR reduce production instruction -> BEGIN list(instruction) END 
-- On END reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On END reduce production instruction -> BEGIN list(instruction) END 
-- On ELSE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On ELSE reduce production instruction -> BEGIN list(instruction) END 
-- On DO reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On DO reduce production instruction -> BEGIN list(instruction) END 
-- On DEFAULT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On DEFAULT reduce production instruction -> BEGIN list(instruction) END 
-- On CONTINUE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On CONTINUE reduce production instruction -> BEGIN list(instruction) END 
-- On CASE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On CASE reduce production instruction -> BEGIN list(instruction) END 
-- On BREAK reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On BREAK reduce production instruction -> BEGIN list(instruction) END 
-- On BOOL reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On BOOL reduce production instruction -> BEGIN list(instruction) END 
-- On BEGIN reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On BEGIN reduce production instruction -> BEGIN list(instruction) END 
-- On ADD reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END 
-- On ADD reduce production instruction -> BEGIN list(instruction) END 
** Conflict on WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD

State 169:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE . BEGIN list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On BEGIN shift to state 170

State 170:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 171
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 171:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 172

State 172:
conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On VOID reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On SWITCH reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On SUB reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On RETURN reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On PUTCHAR reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On INT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On IF reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On IDENT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On FOR reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On END reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On ELSE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On DO reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On DEFAULT reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On CONTINUE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On CASE reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On BREAK reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On BOOL reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On BEGIN reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 
-- On ADD reduce production conditional -> IF LPAR expression RPAR BEGIN list(instruction) END ELSE BEGIN list(instruction) END 

State 173:
conditional -> IF LPAR expression RPAR instruction . ELSE instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> IF LPAR expression RPAR instruction . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On ELSE shift to state 174
-- On WHILE reduce production conditional -> IF LPAR expression RPAR instruction 
-- On VOID reduce production conditional -> IF LPAR expression RPAR instruction 
-- On SWITCH reduce production conditional -> IF LPAR expression RPAR instruction 
-- On SUB reduce production conditional -> IF LPAR expression RPAR instruction 
-- On RETURN reduce production conditional -> IF LPAR expression RPAR instruction 
-- On PUTCHAR reduce production conditional -> IF LPAR expression RPAR instruction 
-- On INT reduce production conditional -> IF LPAR expression RPAR instruction 
-- On IF reduce production conditional -> IF LPAR expression RPAR instruction 
-- On IDENT reduce production conditional -> IF LPAR expression RPAR instruction 
-- On FOR reduce production conditional -> IF LPAR expression RPAR instruction 
-- On END reduce production conditional -> IF LPAR expression RPAR instruction 
-- On ELSE reduce production conditional -> IF LPAR expression RPAR instruction 
-- On DO reduce production conditional -> IF LPAR expression RPAR instruction 
-- On DEFAULT reduce production conditional -> IF LPAR expression RPAR instruction 
-- On CONTINUE reduce production conditional -> IF LPAR expression RPAR instruction 
-- On CASE reduce production conditional -> IF LPAR expression RPAR instruction 
-- On BREAK reduce production conditional -> IF LPAR expression RPAR instruction 
-- On BOOL reduce production conditional -> IF LPAR expression RPAR instruction 
-- On BEGIN reduce production conditional -> IF LPAR expression RPAR instruction 
-- On ADD reduce production conditional -> IF LPAR expression RPAR instruction 
** Conflict on ELSE

State 174:
conditional -> IF LPAR expression RPAR instruction ELSE . instruction [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On instruction shift to state 175
-- On conditional shift to state 149

State 175:
conditional -> IF LPAR expression RPAR instruction ELSE instruction . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On VOID reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On SWITCH reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On SUB reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On RETURN reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On PUTCHAR reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On INT reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On IF reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On IDENT reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On FOR reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On END reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On ELSE reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On DO reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On DEFAULT reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On CONTINUE reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On CASE reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On BREAK reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On BOOL reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On BEGIN reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 
-- On ADD reduce production conditional -> IF LPAR expression RPAR instruction ELSE instruction 

State 176:
block_case_list -> expr_case_list list(instruction) . block_case_list [ END DEFAULT ]
-- On CASE shift to state 95
-- On expr_case_list shift to state 99
-- On block_case_list shift to state 177
-- On END reduce production block_case_list -> 
-- On DEFAULT reduce production block_case_list -> 

State 177:
block_case_list -> expr_case_list list(instruction) block_case_list . [ END DEFAULT ]
-- On END reduce production block_case_list -> expr_case_list list(instruction) block_case_list 
-- On DEFAULT reduce production block_case_list -> expr_case_list list(instruction) block_case_list 

State 178:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list . DEFAULT DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 179
-- On DEFAULT shift to state 180

State 179:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On VOID reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On SWITCH reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On SUB reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On RETURN reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On PUTCHAR reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On INT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On IF reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On IDENT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On FOR reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On END reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On ELSE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On DO reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On DEFAULT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On CONTINUE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On CASE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On BREAK reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On BOOL reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On BEGIN reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 
-- On ADD reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list END 

State 180:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT . DOTS2 list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On DOTS2 shift to state 181

State 181:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 . list(instruction) END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE shift to state 84
-- On VOID shift to state 2
-- On SWITCH shift to state 90
-- On SUB shift to state 3
-- On RETURN shift to state 100
-- On PUTCHAR shift to state 108
-- On INT shift to state 6
-- On IF shift to state 113
-- On IDENT shift to state 7
-- On FOR shift to state 118
-- On DO shift to state 131
-- On CONTINUE shift to state 133
-- On BREAK shift to state 135
-- On BOOL shift to state 64
-- On BEGIN shift to state 137
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 138
-- On typ shift to state 139
-- On simple_var_decl shift to state 141
-- On return shift to state 143
-- On loop shift to state 144
-- On list(instruction) shift to state 182
-- On instruction shift to state 147
-- On conditional shift to state 149
-- On END reduce production list(instruction) -> 

State 182:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 183

State 183:
conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On VOID reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On SWITCH reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On SUB reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On RETURN reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On PUTCHAR reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On INT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On IF reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On IDENT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On FOR reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On END reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On ELSE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On DO reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On DEFAULT reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On CONTINUE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On CASE reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On BREAK reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On BOOL reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On BEGIN reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
-- On ADD reduce production conditional -> SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 

State 184:
loop -> WHILE LPAR expression RPAR BEGIN list(instruction) . END [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On END shift to state 185

State 185:
loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END . [ WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD ]
-- On WHILE reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On VOID reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On SWITCH reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On SUB reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On RETURN reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On PUTCHAR reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On INT reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On IF reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On IDENT reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On FOR reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On END reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On ELSE reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On DO reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On DEFAULT reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On CONTINUE reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On CASE reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On BREAK reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On BOOL reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On BEGIN reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 
-- On ADD reduce production loop -> WHILE LPAR expression RPAR BEGIN list(instruction) END 

State 186:
function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) . END [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On END shift to state 187

State 187:
function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END . [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On VOID reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On SUB reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On INT reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On IDENT reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On EOF reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On BOOL reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
-- On ADD reduce production function_decl -> typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 

State 188:
program' -> program . [ # ]
-- On # accept program

State 189:
program -> global_scope_def_list . EOF [ # ]
-- On EOF shift to state 190

State 190:
program -> global_scope_def_list EOF . [ # ]
-- On # reduce production program -> global_scope_def_list EOF 

State 191:
global_scope_def_list -> global_scope_def . global_scope_def_list [ EOF ]
-- On VOID shift to state 2
-- On SUB shift to state 3
-- On INT shift to state 6
-- On IDENT shift to state 7
-- On BOOL shift to state 64
-- On ADD shift to state 65
-- On variable_set shift to state 68
-- On variable_decl_set shift to state 70
-- On typ shift to state 71
-- On simple_var_decl shift to state 141
-- On global_scope_def_list shift to state 192
-- On global_scope_def shift to state 191
-- On function_decl shift to state 193
-- On EOF reduce production global_scope_def_list -> 

State 192:
global_scope_def_list -> global_scope_def global_scope_def_list . [ EOF ]
-- On EOF reduce production global_scope_def_list -> global_scope_def global_scope_def_list 

State 193:
global_scope_def -> function_decl . [ VOID SUB INT IDENT EOF BOOL ADD ]
-- On VOID reduce production global_scope_def -> function_decl 
-- On SUB reduce production global_scope_def -> function_decl 
-- On INT reduce production global_scope_def -> function_decl 
-- On IDENT reduce production global_scope_def -> function_decl 
-- On EOF reduce production global_scope_def -> function_decl 
-- On BOOL reduce production global_scope_def -> function_decl 
-- On ADD reduce production global_scope_def -> function_decl 

