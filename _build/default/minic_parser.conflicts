
** Conflict (shift/reduce) in state 173.
** Token involved: ELSE
** This state is reached from program after reading:

typ IDENT LPAR parameter_list RPAR BEGIN IF LPAR expression RPAR IF LPAR expression RPAR instruction 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
function_decl 
typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
                                         instruction list(instruction) 
                                         conditional 
                                         (?)

** In state 173, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF LPAR expression RPAR instruction ELSE instruction 
                        conditional 
                        IF LPAR expression RPAR instruction . ELSE instruction 

** In state 173, looking ahead at ELSE, reducing production
** conditional -> IF LPAR expression RPAR instruction 
** is permitted because of the following sub-derivation:

IF LPAR expression RPAR instruction ELSE instruction // lookahead token appears
                        conditional // lookahead token is inherited
                        IF LPAR expression RPAR instruction . 

** Conflict (shift/reduce) in state 168.
** Tokens involved: WHILE VOID SWITCH SUB RETURN PUTCHAR INT IF IDENT FOR END ELSE DO DEFAULT CONTINUE CASE BREAK BOOL BEGIN ADD
** The following explanations concentrate on token ELSE.
** This state is reached from program after reading:

typ IDENT LPAR parameter_list RPAR BEGIN IF LPAR expression RPAR BEGIN list(instruction) END 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
function_decl 
typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
                                         instruction list(instruction) 
                                         conditional 
                                         (?)

** In state 168, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF LPAR expression RPAR BEGIN list(instruction) END . ELSE BEGIN list(instruction) END 

** In state 168, looking ahead at ELSE, reducing production
** instruction -> BEGIN list(instruction) END 
** is permitted because of the following sub-derivation:

IF LPAR expression RPAR instruction ELSE instruction // lookahead token appears
                        BEGIN list(instruction) END . 

** Conflict (shift/reduce) in state 97.
** Token involved: CASE
** This state is reached from program after reading:

typ IDENT LPAR parameter_list RPAR BEGIN SWITCH LPAR expression RPAR BEGIN CASE expression DOTS2 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
function_decl 
typ IDENT LPAR parameter_list RPAR BEGIN list(instruction) END 
                                         instruction list(instruction) 
                                         conditional 
                                         SWITCH LPAR expression RPAR BEGIN block_case_list DEFAULT DOTS2 list(instruction) END 
                                                                           (?)

** In state 97, looking ahead at CASE, shifting is permitted
** because of the following sub-derivation:

expr_case_list list(instruction) block_case_list 
CASE expression DOTS2 expr_case_list 
                      . CASE expression DOTS2 

** In state 97, looking ahead at CASE, reducing production
** expr_case_list -> CASE expression DOTS2 
** is permitted because of the following sub-derivation:

expr_case_list list(instruction) block_case_list // lookahead token appears because list(instruction) can vanish and block_case_list can begin with CASE
CASE expression DOTS2 . 

** Conflict (shift/reduce) in state 55.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression ADD expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          (?)

** In state 55, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

int_op 
expression ADD expression 
               bool_op 
               expression . XOR expression 

** In state 55, looking ahead at XOR, reducing production
** int_op -> expression ADD expression 
** is permitted because of the following sub-derivation:

bool_op 
expression XOR expression // lookahead token appears
int_op // lookahead token is inherited
expression ADD expression . 

** Conflict (shift/reduce) in state 53.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression AND expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 53, looking ahead at XOR, reducing production
** bool_op -> expression AND expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression AND expression . 

** In state 53, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression AND expression 
               bool_op 
               expression . XOR expression 

** Conflict (shift/reduce) in state 51.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression BAND expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 51, looking ahead at XOR, reducing production
** bool_op -> expression BAND expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression BAND expression . 

** In state 51, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression BAND expression 
                bool_op 
                expression . XOR expression 

** Conflict (shift/reduce) in state 49.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression BNEQ expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 49, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression BNEQ expression 
                bool_op 
                expression . XOR expression 

** In state 49, looking ahead at XOR, reducing production
** bool_op -> expression BNEQ expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression BNEQ expression . 

** Conflict (shift/reduce) in state 47.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression BOR expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 47, looking ahead at XOR, reducing production
** bool_op -> expression BOR expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression BOR expression . 

** In state 47, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression BOR expression 
               bool_op 
               expression . XOR expression 

** Conflict (shift/reduce) in state 45.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression BXOR expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 45, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression BXOR expression 
                bool_op 
                expression . XOR expression 

** In state 45, looking ahead at XOR, reducing production
** bool_op -> expression BXOR expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression BXOR expression . 

** Conflict (shift/reduce) in state 43.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression DIV expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          (?)

** In state 43, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

int_op 
expression DIV expression 
               bool_op 
               expression . XOR expression 

** In state 43, looking ahead at XOR, reducing production
** int_op -> expression DIV expression 
** is permitted because of the following sub-derivation:

bool_op 
expression XOR expression // lookahead token appears
int_op // lookahead token is inherited
expression DIV expression . 

** Conflict (shift/reduce) in state 41.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression EQ expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 41, looking ahead at XOR, reducing production
** bool_op -> expression EQ expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression EQ expression . 

** In state 41, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression EQ expression 
              bool_op 
              expression . XOR expression 

** Conflict (shift/reduce) in state 39.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression GET expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 39, looking ahead at XOR, reducing production
** bool_op -> expression GET expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression GET expression . 

** In state 39, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression GET expression 
               bool_op 
               expression . XOR expression 

** Conflict (shift/reduce) in state 37.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression GT expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 37, looking ahead at XOR, reducing production
** bool_op -> expression GT expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression GT expression . 

** In state 37, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression GT expression 
              bool_op 
              expression . XOR expression 

** Conflict (shift/reduce) in state 35.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression LET expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 35, looking ahead at XOR, reducing production
** bool_op -> expression LET expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression LET expression . 

** In state 35, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression LET expression 
               bool_op 
               expression . XOR expression 

** Conflict (shift/reduce) in state 33.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression LT expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 33, looking ahead at XOR, reducing production
** bool_op -> expression LT expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression LT expression . 

** In state 33, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression LT expression 
              bool_op 
              expression . XOR expression 

** Conflict (shift/reduce) in state 31.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression MOD expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          (?)

** In state 31, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

int_op 
expression MOD expression 
               bool_op 
               expression . XOR expression 

** In state 31, looking ahead at XOR, reducing production
** int_op -> expression MOD expression 
** is permitted because of the following sub-derivation:

bool_op 
expression XOR expression // lookahead token appears
int_op // lookahead token is inherited
expression MOD expression . 

** Conflict (shift/reduce) in state 29.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression MUL expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          (?)

** In state 29, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

int_op 
expression MUL expression 
               bool_op 
               expression . XOR expression 

** In state 29, looking ahead at XOR, reducing production
** int_op -> expression MUL expression 
** is permitted because of the following sub-derivation:

bool_op 
expression XOR expression // lookahead token appears
int_op // lookahead token is inherited
expression MUL expression . 

** Conflict (shift/reduce) in state 27.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression NEQ expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 27, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression NEQ expression 
               bool_op 
               expression . XOR expression 

** In state 27, looking ahead at XOR, reducing production
** bool_op -> expression NEQ expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression NEQ expression . 

** Conflict (shift/reduce) in state 25.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression OR expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 25, looking ahead at XOR, reducing production
** bool_op -> expression OR expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression OR expression . 

** In state 25, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression OR expression 
              bool_op 
              expression . XOR expression 

** Conflict (shift/reduce) in state 23.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression SUB expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          (?)

** In state 23, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

int_op 
expression SUB expression 
               bool_op 
               expression . XOR expression 

** In state 23, looking ahead at XOR, reducing production
** int_op -> expression SUB expression 
** is permitted because of the following sub-derivation:

bool_op 
expression XOR expression // lookahead token appears
int_op // lookahead token is inherited
expression SUB expression . 

** Conflict (shift/reduce) in state 21.
** Tokens involved: XOR SUB OR NEQ MUL MOD LT LET GT GET EQ DIV BXOR BOR BNEQ BAND AND ADD
** The following explanations concentrate on token XOR.
** This state is reached from program after reading:

IDENT SET expression XOR expression 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
global_scope_def_list EOF 
global_scope_def global_scope_def_list 
variable_decl_set 
variable_set SEMI 
IDENT SET expression 
          bool_op 
          (?)

** In state 21, looking ahead at XOR, shifting is permitted
** because of the following sub-derivation:

expression XOR expression 
               bool_op 
               expression . XOR expression 

** In state 21, looking ahead at XOR, reducing production
** bool_op -> expression XOR expression 
** is permitted because of the following sub-derivation:

expression XOR expression // lookahead token appears
bool_op // lookahead token is inherited
expression XOR expression . 
